extends Node
class_name ExportRoomGMX

const INDENT:String = "  "

const COLOR_NAMES:Array[String] = ["Master", "White", "Orange", "Purple", "Red", "Green", "Blue", "Pink", "Cyan", "Black", "Brown", "Pure", "Glitch", "Stone", "Dynamite", "Silver", "Maroon", "Forest", "Navy", "Ice", "Mud", "Graffiti", "None"]

static var file:FileAccess
static var indents:int = 0
static var idIter:int = 20000000

static var roomID:int = 0
static var idIterStart:int = 20000000

# values labelled bools are ints; 0 if false and -1 if true

static func exportFile(_file:FileAccess) -> void:
	if !Mods.activeModpack: return Saving.errorPopup("Cannot export to .room.gmx without a modpack", "Export Error")

	file = _file
	indents = 0
	idIter = idIterStart
	
	var levelPos:Vector2 = Game.level.position

	file.store_line("<!--This Document is generated by IWLCEditor; add it to your modpack by right-clicking the rooms folder in GameMaker and selecting \"Add Existing Room\"-->")
	startTag("room")
	# header
	storeTag("caption") # some sort of metadata thing
	storeTag("width", Game.level.size.x)
	storeTag("height", Game.level.size.y)
	storeTag("vsnap", 32) # snap size in the room editor
	storeTag("hsnap", 32) # snap size in the room editor
	storeTag("isometric", convertBool(false))
	storeTag("speed", 30) # no clue what this does
	storeTag("persistent", convertBool(false))
	storeTag("colour", 4210688) # background color in hex, in order BBGGRR for some reason
	storeTag("showcolour", convertBool(false)) # whether or not the solid background color is used; if it isnt then the background starts with solid #c0c0c0
	startTagInline("code")
	file.store_line("global.roomID = %s;" % roomID)
	file.store_line('global.msg = "%s";' % sanitizeSoft(Game.level.description))
	file.store_string('global.rm = "%s";' % sanitizeSoft(Game.level.shortNumber.to_upper()))
	endTagInline("code")
	storeTag("enableViews", convertBool(true))
	storeTag("clearViewBackground", convertBool(true))
	storeTag("clearDisplayBuffer", convertBool(true))
	# no idea what these do and cant be bothered to figure out
	startTag("makerSettings")
	storeTag("isSet", 0)
	storeTag("w", 0)
	storeTag("h", 0)
	storeTag("showGrid", 0)
	storeTag("showObjects", 0)
	storeTag("showTiles", 0)
	storeTag("showBackgrounds", 0)
	storeTag("showForegrounds", 0)
	storeTag("showViews", 0)
	storeTag("deleteUnderlyingObj", 0)
	storeTag("deleteUnderlyingTiles", 0)
	storeTag("page", 0)
	storeTag("xoffset", 0)
	storeTag("yoffset", 0)
	endTag("makerSettings")
	
	startTag("backgrounds")
	storeBackground(true, false, "bGradient")
	for i in 7: storeBackground()
	endTag("backgrounds")
	startTag("views")
	storeView(true, "&lt;undefined&gt;", 0, 0, 800, 608)
	for i in 7: storeView()
	endTag("views")
	
	startTag("instances")
	storeInstance("oDropShadow", Vector2.ZERO)
	if Mods.activeModpack == Mods.modpacks[&"IWLC"]: storeInstance("oRemoteLockConnections", Vector2(32,0))
	for object in Game.objects.values(): object.gameMakerName = generateInst()
	for object in Game.objects.values():
		match object.get_script():
			KeyBulk:
				var code:String = ""
				match object.type:
					KeyBulk.TYPE.EXACT: code += "type=key_EXACT;&#xA;"
					KeyBulk.TYPE.STAR: code += "type=key_UNSTAR;&#xA;" if object.un else "type=key_STAR;&#xA;"
					KeyBulk.TYPE.ROTOR:
						if M.eq(object.count, M.nONE): code += "type=key_SIGNFLIP;&#xA;"
						elif M.eq(object.count, M.I): code += "type=key_POSROTOR;&#xA;"
						elif M.eq(object.count, M.nI): code += "type=key_NEGROTOR;&#xA;"
					KeyBulk.TYPE.CURSE: code += "type=key_UNCURSE;&#xA;" if object.un else "type=key_CURSE;&#xA;"
				if object.type in [KeyBulk.TYPE.NORMAL, KeyBulk.TYPE.EXACT]:
					if M.neq(M.r(object.count), M.ONE): code += "count = %s;&#xA;" % M.str(M.r(object.count))
					if M.ex(M.i(object.count)): code += "icount = %s;&#xA;" % M.str(M.ir(object.count))
				if object.infinite: code += "inf = 1;&#xA;"
				storeInstance("oKey" + COLOR_NAMES[object.color], object.position-levelPos, code, object.gameMakerName)
			Door:
				var objName:String = ""
				var code:String = ""
				match object.type:
					Door.TYPE.SIMPLE: objName = "oDoor" + COLOR_NAMES[object.colorSpend]
					Door.TYPE.COMBO: objName = "oDoorCombo"
					Door.TYPE.GATE: objName = "oGate"
				if object.size.x != 32: code += "w = %s;&#xA;" % (object.size.x / 32)
				if object.size.y != 32: code += "h = %s;&#xA;" % (object.size.y / 32)
				if M.neq(M.r(object.copies), M.ONE): code += "copies = %s;&#xA;" % M.str(M.r(object.copies))
				if M.ex(M.i(object.copies)): code += "icopies = %s;&#xA;" % M.str(M.ir(object.copies))
				if object.frozen: code += "aura[0] = 1;&#xA;"
				if object.crumbled: code += "aura[1] = 1;&#xA;"
				if object.painted: code += "aura[2] = 1;&#xA;"
				if object.type == Door.TYPE.SIMPLE:
					var lock:Lock = object.locks[0]
					if lock.color != object.colorSpend: code += "color = %s;&#xA;" % lock.color
					if lock.type != Lock.TYPE.NORMAL: code += "type = %s;&#xA;" % lock.type
					if M.neq(M.r(lock.count), M.ONE): code += "count = %s;&#xA;" % M.str(M.r(lock.count))
					if M.ex(M.i(lock.count)): code += "icount = %s;&#xA;" % M.str(M.ir(lock.count))
					if lock.type in [Lock.TYPE.BLAST, Lock.TYPE.ALL] and Mods.activeModpack == Mods.modpacks[&"IWLC"]:
						if M.ex(M.r(lock.denominator)): code += "denom = %s;&#xA;" % M.str(M.r(lock.denominator))
						if M.ex(M.i(lock.denominator)): code += "idenom = %s;&#xA;" % M.str(M.ir(lock.denominator))
					if lock.type == Lock.TYPE.EXACT and (M.ex(M.i(lock.count)) or lock.zeroI): code += "exactI = 1;&#xA;"
					if lock.isPartial: code += "isPartial = 1;&#xA;"
					if lock.negated: code += "negated = 1;&#xA;"
					if lock.armament: code += "armament = 1;&#xA;"
				else:
					if object.type == Door.TYPE.COMBO: code += "colorSpend = %s;&#xA;" % object.colorSpend
					for lock in object.locks:
						var spriteName:String = "sprLock"
						if lock.configuration != Lock.CONFIGURATION.NONE: spriteName += Lock.CONFIGURATION_NAMES[lock.configuration]
						else: spriteName += Lock.SIZE_TYPE_NAMES[lock.sizeType]
						var advanced:bool = Mods.activeModpack == Mods.modpacks[&"IWLC"] and (M.ex(M.i(lock.count)) or lock.zeroI or lock.isPartial or lock.type in [Lock.TYPE.BLAST, Lock.TYPE.ALL] or lock.negated or lock.armament)
						if advanced: code += ("scrComboAdvAdd(color_%s,%s,%s,lock_%s,%s,%s,%s,%s,%s,%s,%s,%s);&#xA;" % [COLOR_NAMES[lock.color].to_upper(), M.str(M.r(lock.count)), M.str(M.ir(lock.count)), Lock.TYPE_NAMES[lock.type].to_upper(), lock.position.x, lock.position.y, spriteName, lock.isPartial or M.ex(M.i(lock.count)) or lock.zeroI, M.str(M.r(lock.denominator)), M.str(M.ir(lock.denominator)), lock.negated, lock.armament])
						else: code += ("scrComboAdd(color_%s,%s,%s,lock_%s,%s,%s,%s);&#xA;" % [COLOR_NAMES[lock.color].to_upper(), M.str(M.r(lock.count)), M.str(M.ir(lock.count)), Lock.TYPE_NAMES[lock.type].to_upper(), lock.position.x, lock.position.y, spriteName])
				if object.remoteLocks:
					code += "remoteLocks = %s;&#xA;" % len(object.remoteLocks)
					var index:int = 0
					for remoteLock in object.remoteLocks:
						code += "remoteLock[%s] = %s;&#xA;" % [index, remoteLock.gameMakerName]
						index += 1
				storeInstance(objName, object.position-levelPos, code, object.gameMakerName)
			RemoteLock:
				var code:String = ""
				if object.configuration != Lock.CONFIGURATION.spr1A:
					var spriteName:String = "sprLock"
					if object.configuration != Lock.CONFIGURATION.NONE: spriteName += Lock.CONFIGURATION_NAMES[object.configuration]
					else: spriteName += Lock.SIZE_TYPE_NAMES[object.sizeType]
					code += "sprite = %s;&#xA;" % spriteName
				if object.color != Game.COLOR.WHITE: code += "color = color_%s;&#xA;" % COLOR_NAMES[object.color].to_upper()
				if object.type != Lock.TYPE.NORMAL: code += "type = lock_%s;&#xA;" % Lock.TYPE_NAMES[object.type].to_upper()
				if M.neq(M.r(object.count), M.ONE): code += "count = %s;&#xA;" % M.str(M.r(object.count))
				if M.ex(M.i(object.count)): code += "icount = %s;&#xA;" % M.str(M.ir(object.count))
				if M.ex(M.r(object.denominator)): code += "denom = %s;&#xA;" % M.str(M.r(object.denominator))
				if M.ex(M.i(object.denominator)): code += "idenom = %s;&#xA;" % M.str(M.ir(object.denominator))
				if M.ex(M.i(object.count)) or object.zeroI: code += "exactI = 1;&#xA;"
				if object.isPartial: code += "isPartial = 1;&#xA;"
				if object.negated: code += "negated = 1;&#xA;"
				if object.armament: code += "armament = 1;&#xA;"
				if object.frozen: code += "aura[0] = 1;&#xA;"
				if object.crumbled: code += "aura[1] = 1;&#xA;"
				if object.painted: code += "aura[2] = 1;&#xA;"
				if object.doors:
					code += "doors = %s;&#xA;" % len(object.doors)
					var index:int = 0
					for door in object.doors:
						code += "door[%s] = %s;&#xA;" % [index, door.gameMakerName]
						index += 1
				storeInstance("oRemoteLock", object.position-levelPos, code, object.gameMakerName)
			Goal:
				var code:String = ""
				match object.type:
					Goal.TYPE.STAR: code = "type = 5;&#xA;"
					Goal.TYPE.OMEGA: code = "type = 1;&#xA;"
				storeInstance("oGoal", object.position-levelPos, code, object.gameMakerName)
			KeyCounter:
				var code:String = ""
				var index:int = 0
				for element in object.elements:
					code += "show[%s] = color_%s;&#xA;" % [index, COLOR_NAMES[element.color].to_upper()]
					index += 1
				if object.size.x == KeyCounter.WIDTH_AMOUNT[KeyCounter.WIDTH.MEDIUM]: code += "long = 1;&#xA;"
				elif object.size.x == KeyCounter.WIDTH_AMOUNT[KeyCounter.WIDTH.LONG]: code += "long = 2;&#xA;"
				storeInstance("oKeyHandle", object.position-levelPos+Vector2(17,16), code, object.gameMakerName)
			PlayerSpawn:
				storeInstance("objPlayerStart", object.position-levelPos, "", object.gameMakerName)
				if Game.level.size != Vector2i(800,608): storeInstance("oNewCamera", object.position-levelPos)
			FloatingTile: storeInstance("objBlock", object.position-levelPos, "", object.gameMakerName, object.size/32)
	var tiles:Array[Vector2i] = Game.tiles.get_used_cells()
	tiles.sort()
	if tiles:
		var rect:Rect2i = Rect2i(tiles[0], Vector2.ONE)
		tiles.remove_at(0)
		while tiles:
			var expandedSuccessfully:bool = false
			# horizontal
			var canExpandHorizontal:bool = true
			for y in range(rect.position.y, rect.end.y):
				if Vector2i(rect.end.x, y) not in tiles: canExpandHorizontal = false
			if canExpandHorizontal:
				for y in range(rect.position.y, rect.end.y): tiles.erase(Vector2i(rect.end.x, y))
				expandedSuccessfully = true
				rect = rect.grow_side(SIDE_RIGHT, 1)
			# vertical
			var canExpandVertical:bool = true
			for x in range(rect.position.x, rect.end.x):
				if Vector2i(x, rect.end.y) not in tiles: canExpandVertical = false
			if canExpandVertical:
				for x in range(rect.position.x, rect.end.x): tiles.erase(Vector2i(x, rect.end.y))
				expandedSuccessfully = true
				rect = rect.grow_side(SIDE_BOTTOM, 1)
			if !tiles or !expandedSuccessfully:
				storeInstance("objBlock", Vector2(rect.position*32)-levelPos, "", generateInst(), rect.size)
				if tiles:
					rect = Rect2i(tiles[0], Vector2.ONE)
					tiles.remove_at(0)
	endTag("instances")
	
	startTag("tiles")
	for tile in Game.tiles.get_used_cells():
		storeTile(Vector2(tile)*32-levelPos)
	for object in Game.objects.values():
		if object is FloatingTile:
			storeTile(object.position-levelPos, object.size/32)
	endTag("tiles")
	
	storeTag("PhysicsWorld", 0)
	storeTag("PhysicsWorldTop", 0)
	storeTag("PhysicsWorldLeft", 0)
	storeTag("PhysicsWorldRight", 1024)
	storeTag("PhysicsWorldBottom", 768)
	storeTag("PhysicsWorldGravityX", 0)
	storeTag("PhysicsWorldGravityY", 10)
	storeTag("PhysicsWorldPixToMeters", 0.100000001490116)
	
	endTag("room")

	idIterStart = idIter

static func convertBool(boolean:bool) -> int: return -1 if boolean else 0
static func sanitize(string:String) -> String: return sanitizeSoft(string).replace("\n", "&#xA;")
static func sanitizeSoft(string:String) -> String: return string.replace("<", "&lt;").replace(">", "&gt;").replace("&", "&amp;")
static func generateInst() -> String: return "inst_" + String.num_int64(randi(), 16, true).lpad(8, "0")
static func generateId() -> int: idIter += 1; return idIter

static func startTag(tagName:String) -> void: file.store_line(INDENT.repeat(indents) + "<%s>" % tagName); indents += 1
static func endTag(tagName:String) -> void: indents -= 1; file.store_line(INDENT.repeat(indents) + "</%s>" % tagName)

static func startTagInline(tagName:String) -> void: file.store_string(INDENT.repeat(indents) + "<%s>" % tagName)
static func endTagInline(tagName:String) -> void: file.store_line("</%s>" % tagName)

static func storeTag(tagName:String, inner="") -> void: file.store_line(INDENT.repeat(indents) + "<%s>%s</%s>" % [tagName, inner, tagName])

static func startThing(tagName:String) -> void: file.store_string(INDENT.repeat(indents) + "<%s" % tagName)
static func attrThing(attrName:String, value) -> void: file.store_string(" %s=\"%s\"" % [attrName, value])
static func endThing() -> void: file.store_line("/>")

static func storeBackground(visible:bool=false, foreground:bool=false, _name:String="",
	x:int=0, y:int=0,
	htiled:bool=true, vtiled:bool=true,
	hspeed:int=0, vspeed:int=0,
	stretch:bool=false
) -> void:
	startThing("background")
	attrThing("visible", convertBool(visible))
	attrThing("foreground", convertBool(foreground))
	attrThing("name", _name)
	attrThing("x", x)
	attrThing("y", y)
	attrThing("htiled", htiled)
	attrThing("vtiled", vtiled)
	attrThing("hspeed", hspeed)
	attrThing("vspeed", vspeed)
	attrThing("stretch", convertBool(stretch))
	endThing()

static func storeView(visible:bool=false, objName:String="&lt;undefined&gt;",
	xview:int=0, yview:int=0,
	wview:int=1024, hview:int=768,
	xport:int=0, yport:int=0,
	wport:int=1024, hport:int=768,
	hborder:int=32, vborder:int=32,
	hspeed:int=-1, vspeed:int=-1
) -> void:
	startThing("view")
	attrThing("visible", convertBool(visible))
	attrThing("objName", objName)
	attrThing("xview", xview)
	attrThing("yview", yview)
	attrThing("wview", wview)
	attrThing("hview", hview)
	attrThing("xport", xport)
	attrThing("yport", yport)
	attrThing("wport", wport)
	attrThing("hport", hport)
	attrThing("hborder", hborder)
	attrThing("vborder", vborder)
	attrThing("hspeed", hspeed)
	attrThing("vspeed", vspeed)
	endThing()

static func storeTile(position:Vector2i, # location in the level
	scale:Vector2=Vector2.ONE,
	w:int=32, h:int=32,
	bgName:String="bAllTiles2", # tile atlas
	xo:int=64, yo:int=0, # location in the tile atlas
	depth:int=1000001, locked:bool=false, colour:int=4294967295
) -> void:
	startThing("tile")
	attrThing("bgName", bgName)
	attrThing("x", position.x)
	attrThing("y", position.y)
	attrThing("w", w)
	attrThing("h", h)
	attrThing("xo", xo)
	attrThing("yo", yo)
	attrThing("id", generateId())
	attrThing("name", generateInst())
	attrThing("depth", depth)
	attrThing("locked", convertBool(locked))
	attrThing("colour", colour)
	attrThing("scaleX", scale.x)
	attrThing("scaleY", scale.y)
	endThing()

static func storeInstance(objName:String, position:Vector2i,
	code:String="", _name:String=generateInst(),
	scale:Vector2=Vector2.ONE,
	locked:bool=false, colour:int=4294967295, rotation:float=0
) -> void:
	startThing("instance")
	attrThing("objName", objName)
	attrThing("x", position.x)
	attrThing("y", position.y)
	attrThing("name", _name)
	attrThing("locked", convertBool(locked))
	attrThing("code", code)
	attrThing("scaleX", scale.x)
	attrThing("scaleY", scale.y)
	attrThing("colour", colour)
	attrThing("rotation", rotation)
	endThing()
