shader_type canvas_item;

uniform vec4 GRID_COLOR:source_color;
uniform vec3 OUTOFBOUNDS_COLOR:source_color;

global uniform vec2 LEVEL_POS;
global uniform vec2 LEVEL_SIZE;

uniform vec2 screenPosition; // where the top left corner of the screen is, in worldspace
uniform vec2 mousePosition = vec2(0,0); // where the mouse is, in worldspace
global uniform float RCAMERA_ZOOM = 1; // reciprocal of camera zoom
uniform vec2 tileSize = vec2(32,32);

vec3 lerpColor(vec3 color1, vec3 color2, float t) {
	return color1 * (1.0-t) + color2 * t;
}

float lengthSquared(vec2 vector) {
	return vector.x*vector.x + vector.y*vector.y;
}

void fragment() {
	vec2 XY = FRAGCOORD.xy*RCAMERA_ZOOM + screenPosition;
	if (XY.x < LEVEL_POS.x || XY.y < LEVEL_POS.y || XY.x - LEVEL_POS.x > LEVEL_SIZE.x || XY.y - LEVEL_POS.y > LEVEL_SIZE.y) {
		// draw level bounds
		COLOR.rgb = lerpColor(COLOR.rgb, OUTOFBOUNDS_COLOR, 0.5);
	}
	float gridAlpha = 0.0;
	if ((tileSize.x <= 8.0 && mod(XY.x,8.0) < RCAMERA_ZOOM) || (tileSize.y <= 8.0 && mod(XY.y,8.0) < RCAMERA_ZOOM)) gridAlpha = 0.3;
	if ((tileSize.x <= 16.0 && mod(XY.x,16.0) < RCAMERA_ZOOM) || (tileSize.y <= 16.0 && mod(XY.y,16.0) < RCAMERA_ZOOM)) gridAlpha = 0.35;
	if ((tileSize.x <= 32.0 && mod(XY.x,32.0) < RCAMERA_ZOOM) || (tileSize.y <= 32.0 && mod(XY.y,32.0) < RCAMERA_ZOOM)) gridAlpha = 1.0;
	COLOR.rgb = lerpColor(COLOR.rgb,GRID_COLOR.rgb,GRID_COLOR.a*gridAlpha*(1.0-min(lengthSquared(mousePosition-XY)/1e4,1.0)));
}
